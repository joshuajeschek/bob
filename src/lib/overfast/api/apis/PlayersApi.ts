//@ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * OverFast API
 * OverFast API gives data about Overwatch 2 heroes, gamemodes, maps and players statistics by scraping Blizzard pages. Built with **FastAPI** and **Beautiful Soup**, and uses **nginx** as reverse proxy and **Redis** for caching. By using a Refresh-Ahead cache system, it minimizes calls to Blizzard pages (which can be very slow), and quickly returns accurate data to users.  In players statistics endpoints, several conversions are made for convenience : - all **duration values** are converted into **seconds** (integer) - **percent values** are exposed as **integers** instead of a string with a percent symbol - integer and float string representations are converted into the concerned type  Swagger UI (useful for trying API calls) : https://overfast-api.tekrop.fr/docs
 *
 * The version of the OpenAPI document: 2.17.2
 * Contact: vporchet@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
	BlizzardErrorMessage,
	CareerStats,
	HTTPValidationError,
	HeroKeyCareerFilter,
	InternalServerErrorMessage,
	Player,
	PlayerCareerStats,
	PlayerGamemode,
	PlayerParserErrorMessage,
	PlayerPlatform,
	PlayerPrivacy,
	PlayerSearchResult,
	PlayerStatsSummary,
	PlayerSummary
} from '../models';
import {
	BlizzardErrorMessageFromJSON,
	BlizzardErrorMessageToJSON,
	CareerStatsFromJSON,
	CareerStatsToJSON,
	HTTPValidationErrorFromJSON,
	HTTPValidationErrorToJSON,
	HeroKeyCareerFilterFromJSON,
	HeroKeyCareerFilterToJSON,
	InternalServerErrorMessageFromJSON,
	InternalServerErrorMessageToJSON,
	PlayerFromJSON,
	PlayerToJSON,
	PlayerCareerStatsFromJSON,
	PlayerCareerStatsToJSON,
	PlayerGamemodeFromJSON,
	PlayerGamemodeToJSON,
	PlayerParserErrorMessageFromJSON,
	PlayerParserErrorMessageToJSON,
	PlayerPlatformFromJSON,
	PlayerPlatformToJSON,
	PlayerPrivacyFromJSON,
	PlayerPrivacyToJSON,
	PlayerSearchResultFromJSON,
	PlayerSearchResultToJSON,
	PlayerStatsSummaryFromJSON,
	PlayerStatsSummaryToJSON,
	PlayerSummaryFromJSON,
	PlayerSummaryToJSON
} from '../models';

export interface GetPlayerCareerPlayersPlayerIdGetRequest {
	playerId: string;
}

export interface GetPlayerCareerStatsPlayersPlayerIdStatsCareerGetRequest {
	playerId: string;
	gamemode: PlayerGamemode;
	platform?: PlayerPlatform;
	hero?: HeroKeyCareerFilter;
}

export interface GetPlayerStatsPlayersPlayerIdStatsGetRequest {
	playerId: string;
	gamemode: PlayerGamemode;
	platform?: PlayerPlatform;
	hero?: HeroKeyCareerFilter;
}

export interface GetPlayerStatsSummaryPlayersPlayerIdStatsSummaryGetRequest {
	playerId: string;
	gamemode?: PlayerGamemode;
	platform?: PlayerPlatform;
}

export interface GetPlayerSummaryPlayersPlayerIdSummaryGetRequest {
	playerId: string;
}

export interface SearchPlayersPlayersGetRequest {
	name: string;
	privacy?: PlayerPrivacy;
	orderBy?: string;
	offset?: number;
	limit?: number;
}

/**
 *
 */
export class PlayersApi extends runtime.BaseAPI {
	/**
	 * Get all player data : summary and statistics with labels.<br />**Cache TTL : 1 hour.**
	 * Get all player data
	 */
	async getPlayerCareerPlayersPlayerIdGetRaw(
		requestParameters: GetPlayerCareerPlayersPlayerIdGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Player>> {
		if (requestParameters.playerId === null || requestParameters.playerId === undefined) {
			throw new runtime.RequiredError(
				'playerId',
				'Required parameter requestParameters.playerId was null or undefined when calling getPlayerCareerPlayersPlayerIdGet.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const response = await this.request(
			{
				path: `/players/{player_id}`.replace(`{${'player_id'}}`, encodeURIComponent(String(requestParameters.playerId))),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PlayerFromJSON(jsonValue));
	}

	/**
	 * Get all player data : summary and statistics with labels.<br />**Cache TTL : 1 hour.**
	 * Get all player data
	 */
	async getPlayerCareerPlayersPlayerIdGet(
		requestParameters: GetPlayerCareerPlayersPlayerIdGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Player> {
		const response = await this.getPlayerCareerPlayersPlayerIdGetRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Career contains numerous statistics grouped by heroes and categories (combat, game, best, hero specific, average, etc.). Filter them on specific platform and gamemode (mandatory). You can even retrieve data about a specific hero of your choice.<br />**Cache TTL : 1 hour.**
	 * Get player career stats
	 */
	async getPlayerCareerStatsPlayersPlayerIdStatsCareerGetRaw(
		requestParameters: GetPlayerCareerStatsPlayersPlayerIdStatsCareerGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<PlayerCareerStats>> {
		if (requestParameters.playerId === null || requestParameters.playerId === undefined) {
			throw new runtime.RequiredError(
				'playerId',
				'Required parameter requestParameters.playerId was null or undefined when calling getPlayerCareerStatsPlayersPlayerIdStatsCareerGet.'
			);
		}

		if (requestParameters.gamemode === null || requestParameters.gamemode === undefined) {
			throw new runtime.RequiredError(
				'gamemode',
				'Required parameter requestParameters.gamemode was null or undefined when calling getPlayerCareerStatsPlayersPlayerIdStatsCareerGet.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.gamemode !== undefined) {
			queryParameters['gamemode'] = requestParameters.gamemode;
		}

		if (requestParameters.platform !== undefined) {
			queryParameters['platform'] = requestParameters.platform;
		}

		if (requestParameters.hero !== undefined) {
			queryParameters['hero'] = requestParameters.hero;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const response = await this.request(
			{
				path: `/players/{player_id}/stats/career`.replace(`{${'player_id'}}`, encodeURIComponent(String(requestParameters.playerId))),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PlayerCareerStatsFromJSON(jsonValue));
	}

	/**
	 * Career contains numerous statistics grouped by heroes and categories (combat, game, best, hero specific, average, etc.). Filter them on specific platform and gamemode (mandatory). You can even retrieve data about a specific hero of your choice.<br />**Cache TTL : 1 hour.**
	 * Get player career stats
	 */
	async getPlayerCareerStatsPlayersPlayerIdStatsCareerGet(
		requestParameters: GetPlayerCareerStatsPlayersPlayerIdStatsCareerGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<PlayerCareerStats> {
		const response = await this.getPlayerCareerStatsPlayersPlayerIdStatsCareerGetRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * This endpoint exposes the same data as the previous one, except it also exposes labels of the categories and statistics.<br />**Cache TTL : 1 hour.**
	 * Get player stats with labels
	 */
	async getPlayerStatsPlayersPlayerIdStatsGetRaw(
		requestParameters: GetPlayerStatsPlayersPlayerIdStatsGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<CareerStats>> {
		if (requestParameters.playerId === null || requestParameters.playerId === undefined) {
			throw new runtime.RequiredError(
				'playerId',
				'Required parameter requestParameters.playerId was null or undefined when calling getPlayerStatsPlayersPlayerIdStatsGet.'
			);
		}

		if (requestParameters.gamemode === null || requestParameters.gamemode === undefined) {
			throw new runtime.RequiredError(
				'gamemode',
				'Required parameter requestParameters.gamemode was null or undefined when calling getPlayerStatsPlayersPlayerIdStatsGet.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.gamemode !== undefined) {
			queryParameters['gamemode'] = requestParameters.gamemode;
		}

		if (requestParameters.platform !== undefined) {
			queryParameters['platform'] = requestParameters.platform;
		}

		if (requestParameters.hero !== undefined) {
			queryParameters['hero'] = requestParameters.hero;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const response = await this.request(
			{
				path: `/players/{player_id}/stats`.replace(`{${'player_id'}}`, encodeURIComponent(String(requestParameters.playerId))),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => CareerStatsFromJSON(jsonValue));
	}

	/**
	 * This endpoint exposes the same data as the previous one, except it also exposes labels of the categories and statistics.<br />**Cache TTL : 1 hour.**
	 * Get player stats with labels
	 */
	async getPlayerStatsPlayersPlayerIdStatsGet(
		requestParameters: GetPlayerStatsPlayersPlayerIdStatsGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<CareerStats> {
		const response = await this.getPlayerStatsPlayersPlayerIdStatsGetRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get player statistics summary, with stats usually used for tracking progress : winrate, kda, damage, healing, etc. <br /> Data is regrouped in 3 sections : general (sum of all stats), roles (sum of stats for each role) and heroes (stats for each hero).<br /> Depending on filters, data from both competitive and quickplay, and/or pc and console will be merged.<br />Default behaviour : all gamemodes and platforms are taken in account.<br />**Cache TTL : 1 hour.**
	 * Get player stats summary
	 */
	async getPlayerStatsSummaryPlayersPlayerIdStatsSummaryGetRaw(
		requestParameters: GetPlayerStatsSummaryPlayersPlayerIdStatsSummaryGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<PlayerStatsSummary>> {
		if (requestParameters.playerId === null || requestParameters.playerId === undefined) {
			throw new runtime.RequiredError(
				'playerId',
				'Required parameter requestParameters.playerId was null or undefined when calling getPlayerStatsSummaryPlayersPlayerIdStatsSummaryGet.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.gamemode !== undefined) {
			queryParameters['gamemode'] = requestParameters.gamemode;
		}

		if (requestParameters.platform !== undefined) {
			queryParameters['platform'] = requestParameters.platform;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const response = await this.request(
			{
				path: `/players/{player_id}/stats/summary`.replace(`{${'player_id'}}`, encodeURIComponent(String(requestParameters.playerId))),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PlayerStatsSummaryFromJSON(jsonValue));
	}

	/**
	 * Get player statistics summary, with stats usually used for tracking progress : winrate, kda, damage, healing, etc. <br /> Data is regrouped in 3 sections : general (sum of all stats), roles (sum of stats for each role) and heroes (stats for each hero).<br /> Depending on filters, data from both competitive and quickplay, and/or pc and console will be merged.<br />Default behaviour : all gamemodes and platforms are taken in account.<br />**Cache TTL : 1 hour.**
	 * Get player stats summary
	 */
	async getPlayerStatsSummaryPlayersPlayerIdStatsSummaryGet(
		requestParameters: GetPlayerStatsSummaryPlayersPlayerIdStatsSummaryGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<PlayerStatsSummary> {
		const response = await this.getPlayerStatsSummaryPlayersPlayerIdStatsSummaryGetRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get player summary : name, avatar, competitive ranks, etc. <br />**Cache TTL : 1 hour.**
	 * Get player summary
	 */
	async getPlayerSummaryPlayersPlayerIdSummaryGetRaw(
		requestParameters: GetPlayerSummaryPlayersPlayerIdSummaryGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<PlayerSummary>> {
		if (requestParameters.playerId === null || requestParameters.playerId === undefined) {
			throw new runtime.RequiredError(
				'playerId',
				'Required parameter requestParameters.playerId was null or undefined when calling getPlayerSummaryPlayersPlayerIdSummaryGet.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const response = await this.request(
			{
				path: `/players/{player_id}/summary`.replace(`{${'player_id'}}`, encodeURIComponent(String(requestParameters.playerId))),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PlayerSummaryFromJSON(jsonValue));
	}

	/**
	 * Get player summary : name, avatar, competitive ranks, etc. <br />**Cache TTL : 1 hour.**
	 * Get player summary
	 */
	async getPlayerSummaryPlayersPlayerIdSummaryGet(
		requestParameters: GetPlayerSummaryPlayersPlayerIdSummaryGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<PlayerSummary> {
		const response = await this.getPlayerSummaryPlayersPlayerIdSummaryGetRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Search for a given player by using his username. You should be able to find the associated player_id to use in order to request career data.<br />**Cache TTL : 1 hour.**
	 * Search for a specific player
	 */
	async searchPlayersPlayersGetRaw(
		requestParameters: SearchPlayersPlayersGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<PlayerSearchResult>> {
		if (requestParameters.name === null || requestParameters.name === undefined) {
			throw new runtime.RequiredError(
				'name',
				'Required parameter requestParameters.name was null or undefined when calling searchPlayersPlayersGet.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.name !== undefined) {
			queryParameters['name'] = requestParameters.name;
		}

		if (requestParameters.privacy !== undefined) {
			queryParameters['privacy'] = requestParameters.privacy;
		}

		if (requestParameters.orderBy !== undefined) {
			queryParameters['order_by'] = requestParameters.orderBy;
		}

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		const response = await this.request(
			{
				path: `/players`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PlayerSearchResultFromJSON(jsonValue));
	}

	/**
	 * Search for a given player by using his username. You should be able to find the associated player_id to use in order to request career data.<br />**Cache TTL : 1 hour.**
	 * Search for a specific player
	 */
	async searchPlayersPlayersGet(
		requestParameters: SearchPlayersPlayersGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<PlayerSearchResult> {
		const response = await this.searchPlayersPlayersGetRaw(requestParameters, initOverrides);
		return await response.value();
	}
}
